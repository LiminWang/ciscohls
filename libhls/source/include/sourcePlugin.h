#ifndef _SOURCE_PLUGIN_H_
#define _SOURCE_PLUGIN_H_

/* ****************************************************************************
*
*                   Copyright 2012 Cisco Systems, Inc.
*
*                              CHS Engineering
*                           5030 Sugarloaf Parkway
*                               P.O.Box 465447
*                          Lawrenceville, GA 30042
*
*                        Proprietary and Confidential
*              Unauthorized distribution or copying is prohibited
*                            All rights reserved
*
* No part of this computer software may be reprinted, reproduced or utilized
* in any form or by any electronic, mechanical, or other means, now known or
* hereafter invented, including photocopying and recording, or using any
* information storage and retrieval system, without permission in writing
* from Cisco Systems, Inc.
*
******************************************************************************/

/**
 * @file sourcePlugin.h @date September 22, 2011
 *
 * Component API for platform independent source plugin functions
 * used to extend media source support to the core MediaPlayer library.
 *
 * @addtogroup sourcePluginAPI Source Plugin API
 * @{
 *
 */


#ifdef __cplusplus
extern "C" {
#endif

#define SRC_PTS_NOTIFY_INTERVAL (5)

#define SRC_ERR_MSG_LEN 128 /*!< Maximum error message length */

/*!
* Unique souce plugin session identifier
*/ 

typedef void* srcSessionId_t;

/*
 * 
 * ERROR AND STATUS INFORMATION 
 *
 */

/*! \enum srcStatus_t
 * Enumeration of available return status from plugin and player functions
 */
typedef enum
{
   SRC_SUCCESS = 0, /*!< Operation successful */
   SRC_ERROR        /*!< Error occured - called should check error structure for details */

} srcStatus_t;

/*! \enum srcPluginErrCode_t
 * Error codes that can be returned by source plugins.  This list should be kept generic and not return
 * any error code that are plugin specific.  Plugins may use the errMsg[] param to return additional 
 * details that may be logged and help with debugging or triaging.
 */
typedef enum
{
   SRC_PLUGIN_ERR_GENERAL = 0,              /*!< General error.  Further details should be provided in errMsg[] parameter */
   SRC_PLUGIN_ERR_NOT_INITIALIZED,          /*!< Plugin not initialized */
   SRC_PLUGIN_ERR_INITIALIZED,              /*!< Plugin already initialized and someone tried to initialize it again */
   SRC_PLUGIN_ERR_INITIALIZE_FAILED,        /*!< Plugin initialization failed */
   SRC_PLUGIN_ERR_FINALIZE_FAILED,          /*!< Plugin finalization failed; may not be able to be initialized again */
   SRC_PLUGIN_ERR_INVALID_PARAM,            /*!< Plugin recieved an invalid parameter; details provided in errMsg[] */
   SRC_PLUGIN_ERR_NO_SESSION_AVAILABLE,     /*!< The plugin has reached its maximum number of support sessions */
   SRC_PLUGIN_ERR_SESSION_RESOURCE_FAILED,  /*!< The plugin will support more sessions, but some underlying resourse failed */
   SRC_PLUGIN_ERR_INVALID_SESSION,          /*!< Plugin provided an invalid session */
   SRC_PLUGIN_ERR_UNSUPPORTED,              /*!< Requested operation not supported by plugin at this time */
   SRC_PLUGIN_ERR_NETWORK                   /*!< Generic network error */

} srcPluginErrCode_t;

/*! \struct srcPluginSetData_t
 * Error structure.  Contains error code and detailed error message.
 */
typedef struct
{
   srcPluginErrCode_t errCode;      /*!< Error code.  Use errMsg to provide more details that may be logged by player via black box routine */
   char errMsg[SRC_ERR_MSG_LEN];    /*!< Error string generated by plugin.  This data should be enough for plugin author to narrow down root cause */

} srcPluginErr_t;

/*! \enum srcPluginContentType_t
 * content types 
 */
typedef enum
{
  SRC_PLUGIN_CONTENT_TYPE_LIVE,
  SRC_PLUGIN_CONTENT_TYPE_VOD

} srcPluginContentType_t;

/*
 * 
 * GET/SET OPERATIONS ON PLUGIN
 *
 */

/*! \enum srcPlayerSetCode_t
 * Codes for srcPluginSet() function
 */
typedef enum
{
    SRC_PLUGIN_SET_DATA_SOURCE,     /*!< pData -> char* containing the URL to use for playback */ 
    SRC_PLUGIN_SET_SPEED,           /*!< pData -> float* containing the desired playback speed */ 
    SRC_PLUGIN_SET_POSITION,        /*!< pData -> float* containing the desired position, in ms */ 
    SRC_PLUGIN_SET_MAX_BITRATE,     /*!< pData -> int* containg the maxinum bitrate, in bps */ 
    SRC_PLUGIN_SET_MIN_BITRATE,     /*!< pData -> int* containg the minimum bitrate, in bps */ 
    SRC_PLUGIN_SET_TARGET_BITRATE,  /*!< pData -> int* containg the target bitrate, in bps */ 
    SRC_PLUGIN_SET_END

} srcPluginSetCode_t;

/*! \struct srcPluginSetData_t
 * Structure for srcPluginSet() function
 */
typedef struct
{
    srcPluginSetCode_t setCode;     /*!< Specifies request type */ 
    void* pData;                    /*!< Cast according to setCode */ 

} srcPluginSetData_t;

/*! \enum srcPlayerGetCode_t
 * Codes for srcPluginGet() function
 */
typedef enum
{
    SRC_PLUGIN_GET_NUM_BITRATES,    /*!< pData -> int* ; will contain number of available bitrates */ 
    SRC_PLUGIN_GET_BITRATES,        /*!< pData -> int* ; integer array to hold bitrates. pData[0] MUST specify the
                                                         size of the array, and will be overwritten on return */ 
    SRC_PLUGIN_GET_CURRENT_BITRATE, /*!< pData -> int* ; will contain bitrate of the playlist the plugin is currently
                                                         pulling segments from */
    SRC_PLUGIN_GET_DURATION,        /*!< pData -> float* ; will contain current media duration, in ms */ 
    SRC_PLUGIN_GET_POSITION,        /*!< pData -> float* ; will contain current position, in ms */ 
    SRC_PLUGIN_GET_SPEED,           /*!< pData -> float* ; containing the current playback speed */ 
    SRC_PLUGIN_GET_TRICK_SUPPORTED, /*!< pData -> int* ; 1 - trick modes supported, 0 otherwise */ 
    SRC_PLUGIN_GET_CONTENT_TYPE,    /*!< pData -> srcPluginContentType_t */ 
    SRC_PLUGIN_GET_END

} srcPluginGetCode_t;

/*! \struct srcPluginGetData_t
 * Structure for srcPluginGet() function
 */
typedef struct
{
    srcPluginGetCode_t getCode;     /*!< Specifies request type */ 
    void* pData;                    /*!< Cast according to getCode */

} srcPluginGetData_t;

/*
 * 
 * GET OPERATIONS ON PLAYER
 *
 */

/*!  \enum srcPlayerGetCode_t 
 * Codes for player get() function 
 */
typedef enum
{
   SRC_PLAYER_GET_FIFO_DATA,     /*!< pData -> fifoData_t* ; Get demux fifo data */
   SRC_PLAYER_GET_LAST_PTS,      /*!< pData -> uint64_t* ; Get last 90khz PTS */

} srcPlayerGetCode_t;

/*! \struct srcPlayerGetData_t
*  Structure for player get() function
*/
typedef struct
{
   srcPlayerGetCode_t getCode;  /*!< Specifies request type */
   void * pData;                /*!< Cast according to getCode */ 

} srcPlayerGetData_t;

/*
 * 
 * SET OPERATIONS ON PLAYER
 *
 */

/*! \enum srcPlayerMode_t
 * Player playback modes
 */
typedef enum
{
   SRC_PLAYER_MODE_NORMAL,     /*!< used for "play" mode */
   SRC_PLAYER_MODE_LOW_DELAY,  /*!< use for "trick" modes */
   SRC_PLAYER_MODE_PAUSE       /*!< used to pause playback and hold the last decoded frame */

} srcPlayerMode_t;

/*!  \enum srcPlayerSetCode_t 
 * Codes for player set() function 
 */
typedef enum
{
   SRC_PLAYER_SET_BUFFER_FLUSH,  /*!< pData -> NULL ; Instruct player to flush buffers */
   SRC_PLAYER_SET_MODE           /*!< pData -> srcPlayerMode_t* ; Set player playback mode */

} srcPlayerSetCode_t;

/*! \struct srcPlayerSetData_t
*  Structure for player set() function
*/
typedef struct
{
   srcPlayerSetCode_t setCode;  /*!< Specifies request type */
   void * pData;                /*!< Cast according to setCode */ 

} srcPlayerSetData_t;

/*
 * 
 * CALLBACKS THAT RETURN PLUGIN STATUS TO PLAYER
 *
 */

/*! \enum srcDrmType_t 
 * Enumeration of available DRM methods
 */
typedef enum {
    SRC_DRM_PLAYREADY       /*!< Microsoft PlayReady DRM */
} srcDrmType_t;

/*! \struct srcDrmLicenseInfo_t 
 * Struct defining DRM license details
 */
typedef struct
{
    int programID;          /*!< Program ID that this license applies to */
    srcDrmType_t drmType;   /*!< DRM type */
    char* keyID;            /*!< keyID to match license to data */
    char* drm;              /*!< DRM license info */
} srcDrmLicenseInfo_t;

/*! \enum srcEncType_t
 * Enumeration of available encryption types
 */
typedef enum {
    SRC_ENC_NONE,           /*!< No encryption */
    SRC_ENC_AES128_CBC,     /*!< AES-128 CBC encryption */
    SRC_ENC_AES128_CTR      /*!< AES-128 counter mode encryption */

} srcEncType_t;

/*! \struct srcBufferMetadata_t
 * Struct defining the details of the metadata that the plugin can return with specific buffers.
 */
typedef struct
{
   srcEncType_t encType;    /*!< encryption type */
   char  iv [16];                /*!< initialization vector */
   char* keyURI;            /*!< key URI */
   char  key[16];            /*!< actual key */

} srcBufferMetadata_t;

/*!  \enum srcPluginEvtCode_t 
 * Event codes
 */
typedef enum
{
   SRC_PLUGIN_FORCED_RESUME = 0, /*!< Indicates the plugin has forced playback to resume from pause state */
   SRC_PLUGIN_BUFFERING,         /*!< Indicates that playback has paused due to buffering of data         */
   SRC_PLUGIN_SWITCHED_BITRATE,  /*!< Indicates that plugin has shifted bitrates; pData returned as int and indicates the selected bitrate in bps */
   SRC_PLUGIN_DRM_LICENSE,       /*!< Indicates that plugin has parsed a DRM license; pData returned as srcDrmLicenseInfo_t */
   SRC_PLUGIN_BOF,               /*!< Indicates plugin has paused at beginning of file (fixed start position); pData not used */
   SRC_PLUGIN_BOS,               /*!< Indicates plugin has paused at beginning of stream (floating start position); pData not used */
   SRC_PLUGIN_EOF,               /*!< Indicates plugin has paused at end of file (fixed end position); pData not used */
   SRC_PLUGIN_EOS,               /*!< Indicates plugin has paused at end of stream (floating end position); pData not used */
} srcPluginEvtCode_t;

/*! \struct srcPluginEvt_t
* Structure to hold event information
*/
typedef struct
{
   srcPluginEvtCode_t eventCode;     /*!< Event type */
   void*              pData;         /*!< Cast according to event code */

} srcPluginEvt_t;

/**
 * Callback provided by player for plugin to use to send asynchronous events
 *
 * @param pHandle - session identifier passed into the plugin in
 *                the srcPluginFunc_t::open() call
 * @param pEvt - pointer to #srcPluginEvt_t containing the 
 *             plugin event
 *  
 */ 
typedef void (*pluginEvtCallback_t)( void* pHandle, srcPluginEvt_t* pEvt ); 
/**
 * Callback provided by player for plugin to use to send asynchronous errors
 *
 * @param pHandle - session identifier passed into the plugin in
 *                the srcPluginFunc_t::open() call
 * @param pErr - pointer to #srcPluginErr_t containing the 
 *             plugin error
 *  
 */ 
typedef void (*pluginErrCallback_t)( void* pHandle, srcPluginErr_t* pErr );

/*
 * 
 * CALLBACKS THAT RETURN PLAYER STATUS TO PLUGIN
 *
 */

/*! \struct fifoData_t
* Structure to hold demux fifo size and depth 
*/
typedef struct
{
   unsigned long fifoSize;           /*!< Total number of demux fifo descriptors */
   unsigned long fifoDepth;          /*!< Demux fifo descriptors in use */ 
}fifoData_t;

/*!  \enum srcPlayerEvtCode_t 
 * Event codes
 */
typedef enum
{
   SRC_PLAYER_LAST_PTS = 0,          /*!< pData -> long* containing the last decoded 90khz PTS */ 
   SRC_PLAYER_DISCONTINUITY,         /*!< pData -> long* containing the last decoded 90khz PTS ; indicates a discontinuity was seen */
   SRC_PLAYER_FIFO_DATA,             /*!< pData -> uint32_t* containing the demux fifo size and depth */
   SRC_PLAYER_AUDIO_FIFO_UNDERRUN    /*!< pData -> NULL */ 

} srcPlayerEvtCode_t;

/*! \struct srcPlayerEvt_t
* Structure to hold event information
*/
typedef struct
{
   srcPlayerEvtCode_t evtCode;       /*!< Event type */
   void*              pData;         /*!< Cast according to event code */

} srcPlayerEvt_t;

/**
 * Callback provided by plugin for player to use to send asynchronous events 
 *  
 * @param sessionId - session this event is for
 * @param pEvt - pointer to #srcPlayerEvt_t containing the 
 *             player event
 *  
 * @pre 
 *          - plugin initialized via
 *            srcPluginFunc_t::initialize()
 *          - session specified by sessionId has been created
 *            via srcPluginFunc_t::open()
 *  
 */ 
typedef void (*playerEvtCallback_t)( srcSessionId_t sessionId, srcPlayerEvt_t* pEvt );

/*! \struct srcPluginFunc_t
 * Structure that contains pointers to functions that a plugin must either fullfill or return NULL for.  Returning
 * NULL for a function may result in errors to the higher level application.  
*/
typedef struct
{
   /**
    * Initialization function for the source plugin
    *
    * This API is called once the plugin is loaded with srcPluginLoad() to initialize the plugin.  This must be 
    * called prior to any other calls to the plugin
    *
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable. May be NULL.
    *
    * @pre 
    *       - plugin loaded via srcPluginLoad() 
    *  
    * @post 
    *       - plugin is initialized 
    *  
    * @return #srcStatus_t
    */
   srcStatus_t (*initialize)( srcPluginErr_t* pErr );

   /**
    * Finalize function for the source plugin
    *
    * This API is called to shutdown the source plugin.  Once this 
    * is called no other calls to the plugin are allowed. 
    *
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize()
    *  
    * @post 
    *       - all plugin sessions terminated and all plugin
    *         resources freed
    *  
    * @return #srcStatus_t
    */
   srcStatus_t (*finalize)( srcPluginErr_t* pErr );
  
   /**
    * Register callbacks with plugin
    *
    * This API is called by the player to register callbacks with the plugin for asynchronous events
    * and errors.
    *
    * @param evtCb - #pluginEvtCallback_t event callback function 
    * @param errCb - #pluginErrCallback_t error callback function
    * @param pErr  - Pointer to #srcPluginErr_t error structure if 
    *              applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize() 
    *  
    * @post 
    *       - plugin will use provided functions to signal
    *         asynchronous events and errors
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*registerCB)( pluginEvtCallback_t evtCb, pluginErrCallback_t errCb, srcPluginErr_t* pErr );
   
   /**
    * Opens a session with the plugin
    *
    * This API is called by the player to create a new playback session with the plugin.
    *
    * @param sessionId - Session Id created by plugin.  Used by 
    *                  player in all other API calls.
    * @param pHandle - Opaque handle returned by the player. Plugin
    *                must use this when calling player.
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize() 
    *  
    * @post 
    *       - plugin session created 
    *       - callback for player events registered via
    *         srcPlayerFunc_t::registerCB()
    *       - sessionId points to a unique session identfier
    *  
    * @return #srcStatus_t
    */
   srcStatus_t (*open)( srcSessionId_t* sessionId, void* pHandle, srcPluginErr_t* pErr );

   /**
    * Closes a session with the plugin
    *
    * This API is called by the player to destroy an existing session.
    *
    * @param sessionId - Session to release.
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize() 
    *       - session specified by sessionId has been created via
    *         open()
    *  
    * @post 
    *       - session closed and all session resources released
    *  
    * @return #srcStatus_t
    */
   srcStatus_t (*close)( srcSessionId_t sessionId, srcPluginErr_t* pErr );

   /**
    * Prepare the session and its associated URL
    *
    * This API is called by the player to indicate to the plugin that playback on the session is about to be started.  The plugin can
    * use this to perform any addition setup, pre-fetch content, etc.  Operation may also be a no-op depending on the plugin implementation.
    *
    * @param sessionId - Session to prepare
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize() 
    *       - session specified by sessionId has been created via
    *         open()
    *       - source URL set using SRC_PLUGIN_SET_DATA_SOURCE
    *         option of set() function
    *  
    * @post 
    *       - session is ready to begin playback 
    *  
    * @return #srcStatus_t
    */
   srcStatus_t (*prepare)( srcSessionId_t sessionId, srcPluginErr_t* pErr );
   
   /**
    * Set a desired value in the plugin
    *
    * This API is called by the player to set settings in the 
    * plugin. 
    *
    * @param sessionId - Session to send the request to 
    * @param pSetData - Pointer to #srcPluginSetData_t which 
    *                  contains the data to set
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize() 
    *       - session specified by sessionId has been created via
    *         open()
    *       - SRC_PLUGIN_SET_DATA_SOURCE -- session has NOT been
    *         prepared via prepare()
    *       - SRC_PLUGIN_SET_SPEED -- session has been prepared
    *         via prepare()
    *       - SRC_PLUGIN_SET_POSITION -- session has been
    *         prepared via prepare()
    *       - SRC_PLUGIN_SET_TARGET_BITRATE -- session has not
    *         started playback
    * 
    * @post 
    *       - SRC_PLUGIN_SET_DATA_SOURCE -- session will use
    *         provided URL as the data source
    *       - SRC_PLUGIN_SET_SPEED -- session will play content at
    *         the requested speed
    *       - SRC_PLUGIN_SET_POSITION -- session will start
    *         playback from the requested position at the current
    *         playback speed
    *       - SRC_PLUGIN_SET_MAX_BITRATE -- session will only fetch
    *         data at bitrates below this limit, if possible
    *       - SRC_PLUGIN_SET_MIN_BITRATE -- session will only fetch
    *         data at bitrates above this limit, if possible
    *       - SRC_PLUGIN_SET_TARGET_BITRATE -- once playback is
    *         started, session will begin fetching data at the
    *         bitrate closest to this target bitrate
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*set)(srcSessionId_t sessionId, srcPluginSetData_t* pSetData, srcPluginErr_t* pErr);

   /**
    * Retrieve a desired value from the plugin
    *
    * This API is called by the player to get information from the 
    * plugin. 
    *
    * @param sessionId - Session to send the request to 
    * @param pGetData - Pointer to #srcPluginGetData_t which 
    *                 contains the data to get
    * @param pErr - Pointer to #srcPluginErr_t error structure if 
    *             applicable.  May be NULL.
    *
    * @pre 
    *       - plugin initialized via initialize() 
    *       - session specified by sessionId has been created via
    *         open()
    *       - session has been prepared via prepare()
    *       - pGetData->pData has been allocated to hold the
    *         requested data
    *  
    * @post 
    *       - on SRC_SUCCESS, pGetData->pData contains the desired
    *         information
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*get)(srcSessionId_t sessionId, srcPluginGetData_t* pGetData, srcPluginErr_t* pErr);

} srcPluginFunc_t;

/*! \struct srcPlayerMem_t
* Structure used by plugin to request memory from the player
*/
typedef struct
{
   void * pMem;           /*!< Pointer to a memory block */
   size_t size;           /*!< Size of the memory block pointed by pMem */
}srcPlayerMem_t;

/*! \struct srcPlayerFunc_t
 * Structure that contains pointers to functions that a plugin may call on the player. 
*/
typedef struct
{
   /**
    * Register player event callback
    *
    * This API is called by the plugin to register a callback for 
    * the player to call to send asynchronous events to a specific 
    * plugin session.
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param evtCb - #playerEvtCallback_t player event callback 
    *              function
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*registerCB)( void* pHandle, playerEvtCallback_t evtCb );

   /**
    * Get a buffer from the player
    *
    * This API is called by the plugin to request a data buffer 
    * from the player. 
    *  
    * This function is NON-BLOCKING 
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param buffer - pointer which will be set to the beginning of
    *               the returned buffer
    * @param size - pointer to integer which will be set to the 
    *             size of the returned buffer
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*getBuffer)( void* pHandle, char** buffer, int* size, void **ppPrivate );

   /**
    * Send filled buffer to player
    *
    * This API is called by the plugin to send a filled data buffer 
    * back to the player. 
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param buffer - the data buffer to send
    * @param size - amount of data written into buffer (can be 
    *             smaller than the actual size of the buffer)
    * @param metadata - pointer to #srcBufferMetadata_t providing 
    *                 various information related to this chunk of
    *                 data
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *       - buffer MUST be the result of a successful getBuffer()
    *         call
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*sendBuffer)( void* pHandle, char* buffer, int size, srcBufferMetadata_t* metadata, void *pPrivate ); /* Size should be amount of buffer that was filled */
   
   /**
    * Set player settings
    *
    * This API is called by the plugin to set various settings on 
    * the player. 
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param pSetData - pointer to #srcPlayerSetData_t containing 
    *                 the setting to set on the player
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */   
   srcStatus_t (*set)( void *pHandle, srcPlayerSetData_t *pSetData );

   /**
    * Get player settings
    *
    * This API is called by the plugin to get various settings from
    * the player. 
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param pGetData - pointer to #srcPlayerGetData_t containing 
    *                 the setting to get from the player
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*get)( void *pHandle, srcPlayerGetData_t *pGetData );

   /**
    * Allocate memory 
    *
    * This API is called by the plugin to alloc memory for AV data from 
    * the player. This API is only used by a plugin which perfoms its own 
    * demux buffer management. 
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param pMemData - pointer to #srcPlayerMem_t containing the size of
    *               the memory allocation request and a pointer to be filled 
    *               by the player which points to the memory allocted.
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*allocMem)( void *pHandle, srcPlayerMem_t *pMemData );

   /**
    * Send filled memory to player
    *
    * This API is called by the plugin to send a filled memory block 
    * to the player. 
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param pMem - pointer to the memory block to send
    * @param size - amount of data in the memory block 
    * @param metadata - pointer to #srcBufferMetadata_t providing 
    *                 various information related to this chunk of
    *                 data
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *       - pMem MUST be the result of a successful allocMem() call
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*sendMem)( void* pHandle, char* pMem, int size, srcBufferMetadata_t* metadata );

   /**
    * Free memory 
    *
    * This API is called by the plugin to free the memory allocated using
    * the allocMem API
    *
    * @param pHandle - session identifier passed into the plugin in
    *                the srcPluginFunc_t::open() call
    * @param pMem - pointer to the memory to be freed 
    *  
    * @pre 
    *       - session has been created via srcPluginFunc_t::open()
    *  
    * @post 
    *       - none
    *
    * @return #srcStatus_t
    */
   srcStatus_t (*freeMem)( void *pHandle, void *pMem );

} srcPlayerFunc_t;

/**
 * Load the source plugin
 *
 * This API is called by the player to load a given source 
 * plugin.  Each plugin MUST expose a function of this type 
 * named srcPluginLoad(). 
 *
 * @param pluginTable - pointer to empty #srcPluginErr_t to be 
 *                    populated by the plugin with appropriate
 *                    functions
 * @param playerTable - pointer to #srcPlayerFunc_t populated 
 *                    with function pointers to valid player
 *                    functions
 * @param err - Pointer to #srcPluginErr_t error structure if 
 *            applicable.  May be NULL.
 *  
 * @pre 
 *       - none
 *  
 * @post 
 *       - pluginTable populated with valid plugin functions, or
 *         NULL
 *
 * @return #srcStatus_t
 */
typedef srcStatus_t (*tSrcPluginLoad)( srcPluginFunc_t* pluginTable, srcPlayerFunc_t* playerTable, srcPluginErr_t* err );

/**
 * Unload the source plugin
 *
 * This API is called by the player to unload a given source 
 * plugin. Each plugin MUST expose a function of this type 
 * named srcPluginUnload().
 *
 * @param err - Pointer to #srcPluginErr_t error structure if 
 *            applicable.  May be NULL.
 *  
 * @pre 
 *       - none
 *  
 * @post 
 *       - none
 *
 * @return #srcStatus_t
 */
typedef srcStatus_t (*tSrcPluginUnload)( srcPluginErr_t* err );

#ifdef __cplusplus
}
#endif

/**
 *
 * @}
 */

#endif //end of _SOURCE_PLUGIN_H_
